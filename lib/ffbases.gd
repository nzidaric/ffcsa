#############################################################################
##
#W ffbases.gd                 The FFCSA Package                         nusa
##

#############################################################################
##
#O  GeneratePB( <F> , <elm>)    . . . ..
#O  GeneratePBdownto( <F> , <elm>)    . . . ..
#O  GenerateNB( <F> , <elm>)    . . . ..
##
##
##  <#GAPDoc Label="GeneratePB">
##  <ManSection>
##  <Meth Name="GeneratePB" Arg="F, ffe"/>
##  <Meth Name="GeneratePBdownto" Arg="F, ffe"/>
##  <Meth Name="GenerateNB" Arg="F, ffe"/>
##
##  <Description>
##  <C>GeneratePB</C> returns the polynomial basis of the field <A>F</A>
##  generated by the element <A>ffe</A>=<M>\alpha</M>:
##  <M>PB_{\rm to} = \{1,\alpha, \dots , \alpha^{m-1}\}</M>,
##  where <M>m=[F:K]</M> is the dimension of <A>F</A>. <P/>
##  <C>GeneratePBdownto</C> returns the polynomial basis ofthe field <A>F</A>
##  generated by the element  <A>ffe</A>=<M>\alpha</M>:
##  <M>PB_{\rm Downto} = \{\alpha^{m-1}, \dots ,\alpha, 1 \}</M>,
##  where <M>m=[F:K]</M> is the dimension of <A>F</A>. <P/>
##  <C>GenerateNB</C> returns the normal basis of the field <A>F</A>
##  generated by the normal element  <A>ffe</A>=<M>\alpha</M>:
##  <M>NB = \{\alpha^{q^{i-1}}\}_{i=0}^{m-1}</M>,
##  where <M>m=[F:K]</M> is the dimension of <A>F</A> and
##  <M>q=|K|</M> is the order of the subfield  <A>K</A>. Normal bases
##  are always considered to be direction <E>to</E>. <P/>
##  </Description>
##  </ManSection>
##  <#/GAPDoc>

DeclareOperation( "GenerateNB", [IsField, IsFFE]);
DeclareOperation( "GeneratePB", [IsField, IsFFE]);
DeclareOperation( "GeneratePBdownto", [IsField, IsFFE]);

#############################################################################
##
#O  IsDualBasisPair( <B1> , <B2>)    . . . ..
##
##
##  <#GAPDoc Label="IsDualBasisPair">
##  <ManSection>
##  <Meth Name="IsDualBasisPair" Arg="B1, B2"/>
##  <Description>
##  returns true or false.
##  By <Cite Key="mullen"  Where="(5.1.1)" /> two ordered bases of
##  <M>{\mathbb F}_{q^m}</M> over <M>{\mathbb F}_q</M>
##  <M>B_1=\{\alpha_i\}_0^{m-1}</M> and <M>B_2=\{\beta_i\}_0^{m-1}</M>
##  are <E>dual</E> if for <M>i,j= 0,\dots,m-1</M>:
##  <M>{\rm Tr}^{{\mathbb F}_{q^m}}_{{\mathbb F}_q}(\alpha_i\beta_j)
##  =\delta_{ij}</M>
##  <!--
##  <Display>{\rm Tr}^{{\mathbb F}_{q^m}}_{{\mathbb F}_q}(\alpha_i\beta_j)
##  =\delta_{ij}
##  \begin{cases}
##  0 \;; i\neq j\\
##  1\;; i=j {\color{red} ??? :(}
##  \end{cases}</Display>-->
## An ordered basis is <E>self-dual</E> if it is dual with itself.
##  </Description>
##  </ManSection>
##  <#/GAPDoc>

DeclareOperation("IsDualBasisPair", [IsBasis, IsBasis]);

#############################################################################
##
#O  GeneratorOfDBtoNB( <F> , <elm>)    . . . ..
##
##
##  <#GAPDoc Label="GeneratorOfDBtoNB">
##  <ManSection>
##  <Meth Name="GenerateDBtoNB" Arg="F, a"/>
##  <Meth Name="FindInvCyc" Arg="F, N"/>
##  <Meth Name="GeneratorOfDBtoNB" Arg="F, a"/>
##
##  <Description>
##  <C>FindInvCyc</C> returns polynomial <M> D(x) </M> such that
##  <M>N(x)D(x)\equiv 1\,{\rm mod}\, (x^m+1)</M> by <Ref Sect="NBDBdef"/>.<P/>
##  <C>GeneratorOfDBtoNB</C> returns the generator <A>b</A> of
##  the dual basis: it forms polynomial <C>N</C>=<M>N(x)</M> from
##  elements of <C>NB=GenerateNB(F,a)</C>, then calls <C>FindInvCyc</C>, and
##  generates the element <A>b</A>=<M>\beta</M> by <Ref Sect="NBDBdef"/>.<P/>
##  <C>GenerateDBtoNB</C> returns the dual normal basis <A>DB</A> as
##  <A>GenerateNB(F, b)</A>, where <C>b=GeneratorOfDBtoNB(F,a))</C>.
##  <Example>
##  <![CDATA[
##  gap> K := GF(2);; F := GF(2^4);; x:= X(K, "x");; f:= x^4 + x + 1;;
##  gap> g := GeneratorOfField(F); e := FindNormalFFEs(F)[1]; a := g^e;
##  Z(2^4)
##  3
##  Z(2^4)^3
##  gap> NB := GenerateNB(F, a);
##  Basis( GF(2^4), [ Z(2^4)^3, Z(2^4)^6, Z(2^4)^12, Z(2^4)^9 ] )
##  gap> DB := GenerateDBtoNB(F, a);
##  Basis( GF(2^4), [ Z(2^4)^11, Z(2^4)^7, Z(2^4)^14, Z(2^4)^13 ] )
##  gap> IsDualBasisPair(NB, DB);
##  true
##  gap> b := GeneratorOfDBtoNB(F, a); DB = GenerateNB(F, b);
##  Z(2^4)^11
##  true
##  ]]>
##  </Example>
##  </Description>
##  </ManSection>
##  <#/GAPDoc>
DeclareOperation("FindInvCyc", [IsField, IsPolynomial]);
DeclareOperation( "GeneratorOfDBtoNB", [IsField, IsFFE]);
DeclareOperation( "GenerateDBtoNB", [IsField, IsFFE]);

#############################################################################
##
#O  GeneratorOfDBtoNB( <F> , <elm>)    . . . ..
##
##
##  <#GAPDoc Label="GenerateDBtoPB">
##  <ManSection>
##  <Meth Name="GenerateDBtoPB" Arg="F, a"/>
##  <Meth Name="GenerateDBtoPBdownto" Arg="F, a"/>
##
##  <Description>
##  returns the dual basis to the basis generated by <A>a</A>  following
##  <Ref Sect="PBDBdef"/>.
##  The downto version has reversed order of basis elements.
##  </Description>
##  </ManSection>
##  <#/GAPDoc>

DeclareOperation( "GenerateDBtoPB", [IsField, IsFFE]);
DeclareOperation( "GenerateDBtoPBdownto", [IsField, IsFFE]);

#############################################################################
##
#O  GenerateTFBfromEBlist( <edpl> )    . . . ..
##
##  <#GAPDoc Label="GenerateTFBfromEBlist">
##  <ManSection>
##  <Meth Name="GenerateTFBfromEBlist" 	Arg="EBlist"/>
##  <Meth Name="GenerateTFBfromEDPLwithMB" Arg="EDPlist, Mlist"/>
##  <Meth Name="GenerateTFBfromEDPLwithPB" Arg="EDPlist"/>
##  <Meth Name="GenerateTFBfromEDPLwithPBdownto"  Arg="EDPlist"/>
##  <Meth Name="GenerateTFBfromEDPLwithNB"  Arg="EDPlist"/>
##
##  <Description>
##  <C>GenerateTFBfromEBlist</C> takes an ordered list of bases <A>EBlist</A>,
##  corresponding to
##  <M>{\mathbb F}_{\left(\dots ((p^{{n_1}})^{n_2})\dots\right)^{n_k}}</M>,
##  and returns <M>TFB_{{\mathbb F}_{p^m}/{\mathbb F}_p}</M>.<P/>
##  <C>GenerateTFBfromEDPLwithMB</C> takes an ordered list of extension field
##  defining polynomials <A>EDPlist</A>, and list of extension instructions
##  <C>Mlist</C> containing tuples <C>[BasisType, BasisDirection]</C>,
##  with currently supported values <C>BasisType</C><M>\in</M><C>["PB", "NB"]</C>
##  and <C>BasisDirection</C><M>\in</M><C>["to", "downto"]</C>.
##  The instruction list allows for mixed bases, i.e., a different type of basis
##  on each level, as shown in example below. <P/>
##  Internally, we use GAP <C>Dictionary</C> (Chapter  28 in the GAP reference
##  manual <Cite Key="gapX"/>),
##  and the <C>Mlist</C> instructions to retrieve the strings
##  <C>``GeneratePB''</C>, <C>``GeneratePBdownto''</C>, <C>``GenerateNB''</C>,
##  and concatenate them with brackets and the appropriate strings for
##  field <C>F</C> and <C>ffe</C>.  For example, the resulting string
##  <C>``GenerateNB(F, ffe)''</C> and corresponds exactly to the
##  format of the <Ref Oper="GenerateNB"/> method.
##  Then, using the existing <Ref Oper="EvalString" BookName="ref"/>
##  (Section 27.9-5 in the GAP reference manual <Cite Key="gapX"/>),
##  &GAP; executes the <C>GenerateNB</C> method with the given arguments.
##  Such approach was used in several parts of the automation framework, beyond
##  the &FFCSA; package.  <P/>
##  <C>GenerateTFBfromEDPLwithPB</C>, <C>GenerateTFBfromEDPLwithPBdownto</C>,
##  and <C>GenerateTFBfromEDPLwithNB</C>   are wrappers for
##  <C>GenerateTFBfromEDPLwithMB</C> with <A>Mlist</A> composed only of
##  <C>["PB","to"]</C>, <C>["PB","downto"]</C> or <C>["NB","to"]</C>,
##  respectively.
##  returns the tower field basis of the finite
##  field obtained as a tower of extensions with extension defining polynomials
##  provided as a list of polynomials <M>edpl = [f_1, f_2, \dots, ,f_n]</M>.
##
##  <Example>
##  <![CDATA[
##  gap> K := GF(2);; x:= X(K, "x");;
##  gap> EDPlist := [ x^2+x+Z(2)^0, x^2+Z(2^2)*x+Z(2)^0, x^2+Z(2^2)*x+Z(2^4) ];
##  [ x^2+x+Z(2)^0, x^2+Z(2^2)*x+Z(2)^0, x^2+Z(2^2)*x+Z(2^4) ]
##  gap> Mlist := [["PB", "to"], ["NB", "to"], ["PB", "downto"]];
##  [ [ "PB", "to" ], [ "NB", "to" ], [ "PB", "downto" ] ]
##  gap> TFB1 := GenerateTFBfromEDPLwithMB(EDPlist, Mlist);
##  Basis( GF(2^8), [ Z(2^8)^178, Z(2^8)^8, Z(2^8)^229, Z(2^8)^59, Z(2^4)^6,
##  Z(2^4)^11, Z(2^4)^9, Z(2^4)^14 ] )
##  gap> f1 := EDPlist[1];; f2 := EDPlist[2];; f3 := EDPlist[3];;
##  gap> F1 := FieldExtension(K,  f1);;  lambda := RootOfDefiningPolynomial(F1);
##  Z(2^2)
##  gap> F2 := FieldExtension(F1, f2);;  mu := RootOfDefiningPolynomial(F2);
##  Z(2^4)^6
##  gap> F3 := FieldExtension(F2, f3);;  nu := RootOfDefiningPolynomial(F3);
##  Z(2^8)^76
##  gap> B1 := GeneratePB(F1, lambda);
##  Basis( GF(2^2), [ Z(2)^0, Z(2^2) ] )
##  gap> B2 := GenerateNB(F2, mu);
##  Basis( AsField( GF(2^2), GF(2^4) ), [ Z(2^4)^6, Z(2^4)^9 ] )
##  gap> B3 := GeneratePBdownto(F3, nu);
##  Basis( AsField( AsField( GF(2^2), GF(2^4) ), GF(2^8) ), [ Z(2^8)^76, Z(2)^0 ] )
##  gap> for i in [1..2] do for j in [1..2] do for k in [1..2] do
##  >        Print(TFB1[4*(i-1)+2*(j-1)+ k], "=" ,  B3[i],"*",B2[j],"*",B1[k],
##  >        " is ", TFB1[4*(i-1)+2*(j-1)+ k] = B3[i]*B2[j]*B1[k], "\n");
##  > od; od; od;
##  Z(2^8)^178=Z(2^8)^76*Z(2^4)^6*Z(2)^0 is true
##  Z(2^8)^8=Z(2^8)^76*Z(2^4)^6*Z(2^2) is true
##  Z(2^8)^229=Z(2^8)^76*Z(2^4)^9*Z(2)^0 is true
##  Z(2^8)^59=Z(2^8)^76*Z(2^4)^9*Z(2^2) is true
##  Z(2^4)^6=Z(2)^0*Z(2^4)^6*Z(2)^0 is true
##  Z(2^4)^11=Z(2)^0*Z(2^4)^6*Z(2^2) is true
##  Z(2^4)^9=Z(2)^0*Z(2^4)^9*Z(2)^0 is true
##  Z(2^4)^14=Z(2)^0*Z(2^4)^9*Z(2^2) is true
##  gap> lambda*mu*nu=TFB1[2];
##  true
##  ]]>
##  </Example>


##  </Description>
##  </ManSection>
##  <#/GAPDoc>
DeclareOperation( "CheckMBlistFormat", [ IsList, IsInt]);
DeclareOperation( "GenerateTFBfromEBlist", 	[IsRingElementCollColl]);
DeclareOperation( "GenerateTFBfromEDPLwithMB", [IsRingElementCollection, IsList]);
DeclareOperation( "GenerateTFBfromEDPLwithPB", [IsRingElementCollection]);
DeclareOperation( "GenerateTFBfromEDPLwithPBdownto", [IsRingElementCollection]);
DeclareOperation( "GenerateTFBfromEDPLwithNB", [IsRingElementCollection]);

#############################################################################
##
#O  FindEDPLAllfromEDL( <elist> )    . . . ..
##
##  <#GAPDoc Label="FindEDPLAllfromEDL">
##  <ManSection>
##  <Meth Name="FindEDPLAllfromEDL" Arg="[e1, e2, ..., ek]"/>
##  <Description>
##  for extension degree list (EDL) <A>[e1, e2, ..., ek]</A>, method
##  <C>FindEDPLAllfromEDL</C> returns <C>k</C> lists of monic polynomials
##  of degree <A>ei</A>, <C>i=1,...,k</C>, irreducible over the subfield.
##  It is using the method <Ref Oper="FindMonicIrreduciblePolyAll"/>. 
##  <Example>
##  <![CDATA[
##  gap> K := GF(2);; listall := FindEDPLAllfromEDL([2,2,2]);
##  [ [ x^2+x+Z(2)^0 ], [ x^2+Z(2^2)*x+Z(2)^0, x^2+Z(2^2)*x+Z(2^2), x^2+x+Z(2^2), x^2
##  +x+Z(2^2)^2, x^2+Z(2^2)^2*x+Z(2)^0, x^2+Z(2^2)^2*x+Z(2^2)^2 ], [ x^2+
##  Z(2^4)^3*x+Z(2)^0, x^2+Z(2^4)^3*x+Z(2^2), x^2+Z(2^4)^3*x+Z(2^4)^2,
##     ... OMITTED FOR BREVITY ....
##  x^2+x+Z(2^4)^14, x^2+Z(2^2)*x+Z(2^4), x^2+Z(2^2)*x+Z(2^4)^2,
##     ... OMITTED FOR BREVITY ....
##  x^2+Z(2^4)^13*x+Z(2^4)^14 ] ]
##  gap> EDPlist := [ listall[1][1], listall[2][1], listall[3][25] ];
##  [ x^2+x+Z(2)^0, x^2+Z(2^2)*x+Z(2)^0, x^2+Z(2^2)*x+Z(2^4) ]
##  ]]>
##  </Example>
##  </Description>
##  </ManSection>
##  <#/GAPDoc>
DeclareOperation( "FindEDPLAllfromEDL", [IsList]);
DeclareOperation( "FindEDPLAllfromRDL", [IsList]);
DeclareOperation( "FindEDPLAllfromRDPL", [IsRingElementCollection]);


 DeclareOperation( "CheckTuple", [IsList, IsList]);
 DeclareOperation( "ExtractEDPLs" ,   	[IsRingElementCollColl]);


Print("ffbases.gd  OK,\t");
